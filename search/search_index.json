{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This documentation covers the BacPack System, a component stack developed by BringAuto. This system provides a set of Components designed to create an environment for easy dependency and package management of CMake based projects.</p> <p>The documentation uses terms defined in Term definition.</p>"},{"location":"#main-components","title":"Main Components","text":"<p>The main Components of BacPack system:</p> <ul> <li> <p>Packager - CLI tool that tracks dependencies and  builds Packages</p> </li> <li> <p>Package Tracker - tool that downloads  previously built dependencies for use in CMake based projects</p> </li> </ul>"},{"location":"#project-specific-components","title":"Project specific Components","text":"<p>To use BacPack system, these additional Components must be set up that are specific to each Project or organization:</p> <ul> <li> <p>Package Repository - A Git repository where built Packages are stored and distributed</p> </li> <li> <p>Package Context - A directory structure containing configuration files that define how to  build Packages, including build settings and Docker environments.</p> </li> </ul> <p>These Components are customized for each Project's specific needs - different Projects will have different Packages to build and different build requirements.</p>"},{"location":"#external-tools","title":"External tools","text":"<ul> <li>docker</li> <li>cmakelib</li> </ul>"},{"location":"architecture/","title":"System level architecture","text":"<p>This document describes all Components of BacPack system and how they work together.</p>"},{"location":"architecture/#components","title":"Components","text":"<p>In a nutshell, the BacPack system contains these Components:</p> <ul> <li>Packager</li> <li>Package Repository</li> <li>Package Context</li> <li>Package Tracker</li> <li>Project</li> </ul> <p>The interactions and relationships between these Components are shown on next diagram.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    class Packager\n    class PackageContext\n\n    namespace Docker {\n        class DockerImage\n        class DockerContainer\n    }\n\n    class PackageRepository\n    class Package\n    class Project\n    class PackageTracker\n\n    %% CORE RELATIONSHIPS\n\n    %% Packager uses PackageContext and PackageRepository (Association)\n    Packager --&gt; PackageContext : reads Configs from\n    Packager --&gt; PackageRepository : stores Packages in\n\n    %% Packager builds DockerImage\n    Packager --&gt; DockerImage : builds\n\n    %% PackageRepository aggregates Packages (Aggregation - packages are stored independently)\n    PackageRepository o-- \"0..*\" Package : stores\n\n    %% Docker relationships (Composition - container lifecycle tied to image)\n    DockerImage *-- \"0..1\" DockerContainer : creates\n\n    %% Packager creates packages through build process (Association)\n    Packager ..&gt; DockerContainer : uses for building\n\n    %% EXAMPLE USAGE RELATIONSHIPS\n\n    %% Project uses PackageTracker (Composition - Project owns its tracker)\n    Project *-- PackageTracker : uses\n\n    %% PackageTracker interacts with repository and creates sysroot (Association)\n    PackageTracker --&gt; PackageRepository : retrieves Packages from</code></pre>"},{"location":"architecture/#main-components","title":"Main Components","text":""},{"location":"architecture/#packager","title":"Packager","text":"<p>Packager is a tool for building Packages and Apps. It takes a Package Context as an input.</p> <p>Both <code>build-package</code> and <code>build-app</code> commands build Package or App specified in Package Context in a Docker container based on existing Docker image built by <code>build-image</code> command, create a zip archive of its files and copy it to Package Repository.</p> <p>With <code>create-sysroot</code> command, Packager creates a sysroot directory from Packages in Package Repository for given target platform.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    class Packager {\n      -context: Context\n      -readDockerfiles(context: Context)\n      -readAppConfigs(context: Context)\n      -readPackageConfigs(context: Context)\n      -readAppConfigs(context: Context)\n      +buildImage(context: Context, imageName: string)\n      +buildPackage(context: Context, packageName: string, options: BuildOptions)\n      +buildApp(context: Context, appName: string, options: BuildOptions)\n      +createSysroot(context: Context, imageName: string, repository: PackageRepository, sysrootDir: string)\n    }\n    class PackageContext\n\n    namespace Docker {\n        class DockerImage\n        class DockerContainer\n    }\n\n    class PackageRepository\n\n    %% CORE RELATIONSHIPS\n\n    %% Packager uses PackageContext and PackageRepository (Association)\n    Packager --&gt; PackageContext : reads Configs from\n    Packager --&gt; PackageRepository : stores Packages in\n\n    %% Packager builds DockerImage\n    Packager --&gt; DockerImage : builds\n\n    %% Docker relationships (Composition - container lifecycle tied to image)\n    DockerImage *-- \"0..1\" DockerContainer : creates\n\n    %% Packager creates packages through build process (Association)\n    Packager ..&gt; DockerContainer : uses for building\n\n    %% Packager creates sysroot\n    Packager --&gt; Sysroot : creates and manages</code></pre>"},{"location":"architecture/#package-tracker","title":"Package Tracker","text":"<p>Package Tracker provides CMake macros that handle downloading, caching, and integrating Packages/Apps from Package Repository. Projects link to Package Tracker repository to use Packages built in Package Repository.</p> <p>The Package Tracker links to a Package Repository. This link must be changed to work with Project specific Package Repository.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n  class PackageTracker {\n        -repositoryUrl: string\n        -localCachePath: string\n        +downloadPackage(packageName: string, version: string): Package\n        +setupSysroot(packages: Package[]): Sysroot\n        +resolvePackageDependencies(packageName: string): Package[]\n  }\n\n  Project --&gt; PackageTracker : uses\n\n  %% PackageTracker interacts with repository and creates sysroot (Association)\n  PackageTracker --&gt; PackageRepository : retrieves Packages from</code></pre>"},{"location":"architecture/#project-specific-components","title":"Project specific Components","text":""},{"location":"architecture/#package-repository","title":"Package Repository","text":"<p>Package Repository is a Git repository storage of Packages and Apps, which are built and copied there by Packager.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    class PackageRepository {\n      -gitRepositoryPath: string\n      -isLfsEnabled: boolean\n    }\n    class Package {\n      -packageFiles: file[]\n    }\n\n    %% CORE RELATIONSHIPS\n\n    %% Packager uses PackageRepository (Association)\n    Packager --&gt; PackageRepository : stores Packages in\n\n    %% PackageRepository aggregates Packages (Aggregation - packages are stored independently)\n    PackageRepository o-- \"0..*\" Package : stores\n\n    %% EXAMPLE USAGE RELATIONSHIPS\n\n    %% PackageTracker interacts with repository and creates sysroot (Association)\n    PackageTracker --&gt; PackageRepository : retrieves Packages from</code></pre>"},{"location":"architecture/#package-context","title":"Package Context","text":"<p>Package Context contains definitions of Docker images, Packages and Apps in a strict directory structure. The Packages and Apps must use Docker images defined in the same Package Context.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    namespace PackageContext {\n        class Context {\n            -contextDirectory: string\n        }\n\n        class PackageConfig {\n            -env: Map~string, string~\n            -dependsOn: string[]\n            -gitUri: string\n            -gitRevision: string\n            -cmakeListDir: string\n            -cmakeDefines: Map~string, string~\n            -packageName: string\n            -versionTag: string\n            -platformMode: string\n            -isLibrary: boolean\n            -isDevLib: boolean\n            -isDebug: boolean\n            -dockerImageNames: string[]\n        }\n\n        class AppConfig {\n            -env: Map~string, string~\n            -gitUri: string\n            -gitRevision: string\n            -cmakeListDir: string\n            -cmakeDefines: Map~string, string~\n            -packageName: string\n            -versionTag: string\n            -platformMode: string\n            -isLibrary: boolean\n            -isDevLib: boolean\n            -isDebug: boolean\n            -dockerImageNames: string[]\n        }\n\n        class DockerConfig {\n            -imageName: string\n            -dockerfilePath: string\n        }\n    }\n\n    namespace Docker {\n        class DockerImage\n    }\n\n    %% CORE RELATIONSHIPS\n\n    %% Packager uses Context\n    Packager --&gt; Context : reads Configs from\n\n    %% Context aggregates configuration files (Aggregation - Configs exist as files)\n    Context o-- \"0..*\" PackageConfig : contains\n    Context o-- \"0..*\" AppConfig : contains\n    Context o-- \"1..*\" DockerConfig : contains\n\n    %% Docker relationships (Composition - container lifecycle tied to image)\n    DockerConfig --&gt; DockerImage : defines\n\n    %% Package dependencies (Dependency)\n    PackageConfig ..&gt; PackageConfig : depends on</code></pre>"},{"location":"architecture/#external-tools","title":"External tools","text":""},{"location":"architecture/#cmakelib","title":"cmakelib","text":"<p>Dependency tracking library for CMake. It defines macros for dependency tracking and features caching for efficient use and building of dependencies.</p> <p>The links between cmakelib and other Components are shown on next diagram.</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    class cmakelib\n    class CMLibStorage {\n        -storageUris: string[]\n    }\n    class PackageTracker\n\n    %% PackageTracker uses CMLibStorage (Association)\n    PackageTracker --&gt; cmakelib : uses\n\n    %% CMLibStorage uses cmakelib (Association)\n    cmakelib *-- CMLibStorage : is component of</code></pre> <p>The interactions between cmakelib and other Components when building a Project are shown on next diagram.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Project\n  participant cmakelib\n  participant CMLibStorage\n  participant Package Tracker\n\n  User-&gt;&gt;Project: Initiates Project&lt;br&gt;configuration\n  Project-&gt;&gt;cmakelib: Includes cmakelib with&lt;br&gt;STORAGE component\n  cmakelib-&gt;&gt;CMLibStorage: Asks for storage&lt;br&gt;initialization\n  Package Tracker-&gt;&gt;CMLibStorage: Retrieves Package&lt;br&gt;Tracker\n  CMLibStorage-&gt;&gt;CMLibStorage: Package&lt;br&gt;Tracker initialization\n  CMLibStorage-&gt;&gt;cmakelib: Package Tracker&lt;br&gt;initialized\n  cmakelib-&gt;&gt;Project: Package Tracker&lt;br&gt;initialized\n  Project-&gt;&gt;Package Tracker: Asks for Packages\n  Package Tracker-&gt;&gt;Project: Retrieves Packages\n  Project-&gt;&gt;Project: FIND_PACKAGE&lt;br&gt;for each Package\n  User-&gt;&gt;Project: Initiates Project&lt;br&gt;build\n  Project-&gt;&gt;Project: Build with dependencies</code></pre>"},{"location":"example_usage/","title":"Example usage","text":"<p>The goal of this document is to demonstrate some of the use cases defined in Use Cases. During this tutorial an example CMake based project will be created. This Project will use a dependency - another CMake based project. The dependency will be built and added to the Project using BacPack system. Finally the newly created Project will be added to BacPack system as an App and built.</p> <p>The example Project will use <code>curl</code> dependency for simply printing a html content of <code>https://www.example.com</code> webpage. In the following steps, the <code>curl</code> Package will be defined and built. Then the example Project will be created and configured to use the <code>curl</code> Package.</p>"},{"location":"example_usage/#install-dependencies","title":"Install dependencies","text":"<p>Install the required dependencies for using BacPack system - docker and cmakelib.</p>"},{"location":"example_usage/#create-a-package-context","title":"Create a Package Context","text":"<p>The Package Context is a structure that contains all necessary information for building Packages and Apps. It contains definitions of Docker images, Packages and Apps in a strict directory structure. The Packages and Apps must use only Docker images defined in the same Package Context.</p> <p>The Package Context has following mandatory subdirectories:</p> <ul> <li>package - contains Package definitions</li> <li>app - contains App definitions</li> <li>docker - contains Docker image definitions - Dockerfiles</li> </ul> <p>To track changes in Package Context, it is recommended to create a git repository for it. The command for creating a Package Context as a git repository is:</p> <pre><code>mkdir context &amp;&amp; cd context &amp;&amp; mkdir docker package app &amp;&amp; git init\n</code></pre> <p>The example Package Context contains complete Package Context for this tutorial with all <code>curl</code> and <code>zlib</code> Configs, <code>example-project</code> app and <code>ubuntu2404</code> and <code>fedora41</code> Dockerfiles.</p> Package Context directory structure <p>The following text shows the directory structure of the Package Context after all steps in this tutorial. The <code>package</code>, <code>app</code> and <code>docker</code> directories are mandatory. The <code>&lt;package_group_name&gt;</code> and <code>&lt;app_group_name&gt;</code> refers to Package group described in next section. The <code>...</code> means that the directory can contain more files, but they are not relevant for the purpose of this example. The structure also shows the right place for <code>curl</code> and <code>zlib</code> Packages.</p> <pre><code>&lt;context_directory&gt;\n\u251c\u2500\u2500 docker\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;docker_image_name&gt;\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 Dockerfile\n\u2502   \u251c\u2500\u2500 ubuntu2404\n\u2502   \u2502   \u2514\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 fedora41\n\u2502       \u2514\u2500\u2500 Dockerfile\n\u2502       ...\n\u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 &lt;app_group_name&gt;\n\u2502   \u2502   \u251c\u2500\u2500 app_config_a.json\n\u2502   \u2502   \u2514\u2500\u2500 app_config_b.json\n\u2502   \u2514\u2500\u2500 example-project\n\u2502       \u251c\u2500\u2500 example_project_debug.json\n\u2502       \u2514\u2500\u2500 example_project_release.json\n\u2502       ...\n\u2514\u2500\u2500 package\n    \u251c\u2500\u2500 &lt;package_group_name&gt;\n    \u2502   \u251c\u2500\u2500 package_config_a.json\n    \u2502   \u2514\u2500\u2500 package_config_b.json\n    \u251c\u2500\u2500 curl\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 curl_debug.json\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 curl_release.json\n    \u2514\u2500\u2500 zlib\n        \u251c\u2500\u2500 zlib_debug.json\n        \u2514\u2500\u2500 zlib_release.json\n        ...\n</code></pre>"},{"location":"example_usage/#define-a-package","title":"Define a Package","text":"<p>The example Project uses <code>curl</code> as a dependency, which depends on <code>zlib</code>. The definition files of these Packages (Configs) need to be created inside a Package Context.</p> <p>BacPack system supports building Packages for multiple target platforms. For this the Docker images are used. So in order to build the Packages, the Docker image (build environment) must be defined and created.</p> <p>The following sections describe how to define Docker images and Packages.</p>"},{"location":"example_usage/#define-a-docker-image","title":"Define a Docker image","text":"<p>The Packages are built inside a Docker container created from image specified by Dockerfile. The image defines a build environment for building Packages. Defined Docker image must comply with some requirements, briefly:</p> <ul> <li>CMake must be installed,</li> <li>SSH must be configured with root login and password <code>1234</code>,</li> <li>and <code>uname</code> must be installed.</li> </ul> <p>Additionally all required tools for building supported Packages must be installed (for example compilers).</p> <p>All defined Docker images must be placed in the <code>docker</code> directory of the Package Context. In this directory, each Docker image is defined in its own directory. The name of this directory is the name of the Docker image (see Create a Package Context). This name is used in the Package Configs to specify the Docker image to use for building the Package. The Dockerfile must be named <code>Dockerfile</code>.</p> Dockerfile example <p>The following Dockerfile is used for building <code>curl</code> and <code>zlib</code> Packages for Fedora 41. It installs all required tools and fulfills all requirements. The path to this Dockerfile is <code>context/docker/fedora41/Dockerfile</code>. The <code>fedora41</code> is the name of the Docker image and is used in the Package Configs.</p> <pre><code>FROM fedora:41\n\nUSER root\nRUN echo root:1234 | chpasswd\n\nRUN dnf -y update &amp;&amp; \\\n    dnf -y install  \\\n    automake binutils gcc gcc-c++ git kernel-devel lsb-release make openssh-server openssl-devel patchelf wget \\\n    &amp;&amp; dnf clean all\n\nRUN wget \"https://github.com/Kitware/CMake/releases/download/v3.30.3/cmake-3.30.3-linux-x86_64.sh\" -O cmake.sh &amp;&amp; \\\n    chmod +x cmake.sh &amp;&amp; \\\n    ./cmake.sh --skip-license --prefix=/usr/local &amp;&amp; \\\n    rm ./cmake.sh\n\nRUN dnf -y update &amp;&amp; \\\n    dnf -y remove \\\n      wget\n\nRUN git clone https://github.com/cmakelib/cmakelib.git /cmakelib\nRUN echo \"export CMLIB_DIR=/cmakelib\" &gt;&gt; /root/.bashrc\n\nRUN sed -ri 's/#?PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config\nRUN mkdir -p /run/sshd\n\nRUN ssh-keygen -A\n\nENTRYPOINT [\"/usr/sbin/sshd\", \"-D\", \"-o\", \"ListenAddress=0.0.0.0\"]\n</code></pre>"},{"location":"example_usage/#define-a-package-config","title":"Define a Package Config","text":"<p>Package definition - Config is a JSON file that defines the Package. The Config contains all necessary information for building the Package - the source code repository, the Docker image to use, the CMake options, etc. The Config structure is described in Packager documentation.</p> <p>Some of the important fields of Config are:</p> <ul> <li><code>DependsOn</code> - list of dependency Packages, all Packages in the list must be defined in the same Package Context</li> <li><code>Git/URI</code> - URI to a CMake based git repository with source code of the Package</li> <li><code>Git/Revision</code> - tag or branch to use for build</li> <li><code>Build/CMake/Defines</code> - CMake options</li> <li><code>Package/Name</code> - name of the Package</li> <li><code>DockerMatrix/ImageNames</code> - list of Docker images to build the Package for</li> </ul> <p>Each Package can have multiple variations, which are defined by different Configs. The variations can be for example different build types (Release, Debug), different versions, different target architectures (x86, x64), etc. All variations are part of a so-called Package group. The Package group is a directory containing all variations of the Package. The name of the Package group must be equal to the name of the Package (<code>Package/Name</code> field in Config). The name of the Config file is the name of the variation.</p> <p>There are also 2 types of Configs - Package Configs and App Configs. The only difference between Packages and Apps is that Apps do not support dependencies managed by the BacPack system. Therefore, App Configs do not have a <code>DependsOn</code> field. All other fields are the same for both Package and App Configs.</p> <p>Info</p> <p>Packages can depend only on different Packages in the same Package Context, but not on Apps. In general, Apps can't form any dependency relationships.</p> <p>The dependency relationships of Packages cannot form a cycle.</p> <code>curl</code> Config example <p>The following Config defines <code>curl</code> Package. It defines its dependency on <code>zlib</code> Package, the source code repository, name of the Package, the CMake options and the Docker images to use. It sets the build type to Release and <code>IsDebug</code> to false, so it is a release variation of <code>curl</code> Package. The path to this Config is <code>context/package/curl/curl_release.json</code>.</p> <pre><code>{\n  \"Env\": {},\n  \"DependsOn\": [\n    \"zlib\"\n  ],\n  \"Git\": {\n    \"URI\": \"https://github.com/curl/curl.git\",\n    \"Revision\": \"curl-7_79_1\"\n  },\n  \"Build\": {\n    \"CMake\": {\n      \"Defines\": {\n        \"CMAKE_BUILD_TYPE\": \"Release\"\n      }\n    }\n  },\n  \"Package\": {\n    \"Name\": \"curl\",\n    \"VersionTag\": \"v7.79.1\",\n    \"PlatformString\": {\n      \"Mode\": \"auto\"\n    },\n    \"IsLibrary\": true,\n    \"IsDevLib\": true,\n    \"IsDebug\": false\n  },\n  \"DockerMatrix\": {\n    \"ImageNames\": [\n      \"ubuntu2404\",\n      \"fedora41\"\n    ]\n  }\n}\n</code></pre> <code>zlib</code> Config example <p>The following Config defines release variation of <code>zlib</code> Package. The path to this Config is <code>context/package/zlib/zlib_release.json</code>.</p> <pre><code>{\n  \"Env\": {},\n  \"Git\": {\n    \"URI\": \"https://github.com/madler/zlib.git\",\n    \"Revision\": \"v1.2.11\"\n  },\n  \"Build\": {\n    \"CMake\": {\n      \"Defines\": {\n        \"CMAKE_BUILD_TYPE\": \"Release\"\n      }\n    }\n  },\n  \"Package\": {\n    \"Name\": \"zlib\",\n    \"VersionTag\": \"v1.2.11\",\n    \"PlatformString\": {\n      \"Mode\": \"auto\"\n    },\n    \"IsLibrary\": true,\n    \"IsDevLib\": true,\n    \"IsDebug\": false\n  },\n  \"DockerMatrix\": {\n    \"ImageNames\": [\n      \"ubuntu2404\",\n      \"fedora41\"\n    ]\n  }\n}\n</code></pre>"},{"location":"example_usage/#package-build","title":"Package build","text":"<p>Firstly, the target Docker image must be build. Then if not already created, the Package Repository must be created. Finally the <code>curl</code> Package can be build.</p>"},{"location":"example_usage/#install-packager","title":"Install Packager","text":"<p>Packager is a tool for building Packages and Apps. It is available as a binary release for Linux or it can be built from source. The build instructions are in the Packager repository. The name of the built binary is <code>bap-builder</code>, which is used in next sections.</p>"},{"location":"example_usage/#build-docker-image","title":"Build Docker image","text":"<p>If the used image is not built on the system, it must be built with the <code>build-image</code> Packager command. Following command builds a Docker image based on Dockerfile in given Package Context.</p> <pre><code>bap-builder build-image \\\n            --context context \\\n            --image-name fedora41\n</code></pre>"},{"location":"example_usage/#create-a-package-repository","title":"Create a Package Repository","text":"<p>A Package Repository is a storage for Packages built by Packager. It must be a git repository.</p> <p>For the purpose of this example, a local Package Repository will be used, but usually the Package Repository is present upstream and cloned locally.</p> <p>The creation of Package Repository is basically creating an empty git repository. The following commands will create it in the current directory:</p> <pre><code>mkdir package_repo &amp;&amp; cd package_repo &amp;&amp; git init\n</code></pre>"},{"location":"example_usage/#build-a-package","title":"Build a Package","text":"<p>The Packager command <code>build-package</code> for building Packages requires these parameters:</p> <ul> <li>context</li> <li>image-name</li> <li>output-dir</li> </ul> <p>The <code>context</code> parameter specifies the Package Context path, the <code>image-name</code> selects the target image for Package and <code>output-dir</code> points to the Package Repository.</p> <p>The command for building <code>curl</code> Package is:</p> <pre><code>bap-builder build-package \\\n            --context context \\\n            --image-name fedora41 \\\n            --output-dir package_repo \\\n            --name curl --build-deps\n</code></pre> <p>This command builds a Package <code>curl</code> defined in Context for <code>fedora41</code> image, creates an archive of this Package and copies it to the output-dir (Package Repository). The command with <code>--build-deps</code> flag also builds all dependencies of the given Package. In this case it also builds the <code>zlib</code> Package. Other flags and settings of Packager are described in its documentation.</p> <p>The <code>curl</code> Package can now be used as a dependency for projects.</p>"},{"location":"example_usage/#add-package-to-a-project","title":"Add Package to a Project","text":"<p>The example Project will be built in the following steps. The Project uses <code>curl</code> Package built in previous steps as a dependency.</p>"},{"location":"example_usage/#install-cmakelib","title":"Install cmakelib","text":"<p>First, cmakelib (link in Introduction) must be installed. Follow the README to install it.</p>"},{"location":"example_usage/#set-the-package-tracker","title":"Set the Package Tracker","text":"<p>In the Project root directory, the <code>CMLibStorage.cmake</code> needs to be added with the following content:</p> <pre><code>SET(STORAGE_LIST DEP)\nSET(STORAGE_LIST_DEP \"https://github.com/bacpack-system/package-tracker.git\")\n</code></pre> <p>Info</p> <p>The <code>CMLibStorage.cmake</code> file is a part of STORAGE component of cmakelib. So this component must be enabled with cmakelib. The <code>STORAGE_LIST</code> variable defines the list of storages and <code>STORAGE_LIST_&lt;STORAGE&gt;</code> defines the URL for each storage. In this case the Package Tracker is used.</p> <p>This links the Project with Package Tracker, which by default enables adding Packages from BringAuto's specific Package Repository (The Package Tracker points to Package Repository). Usually the previously built Packages would be used, but for simplicity, the same Packages from BringAuto's specific Package Repository are used instead. These Packages are exactly the same as Packages defined in example Package Context.</p> <p>Note</p> <p>The local Package Repository can't be easily used when building a Project, because currently the BacPack system supports only upstream Package Repositories. The usage of local Package Repository will be added in future releases.</p>"},{"location":"example_usage/#configure-cmakelists","title":"Configure CMakeLists","text":"<p>Following code shows needed configuration of <code>CMakeLists.txt</code> for using <code>curl</code> and <code>zlib</code> Package.</p> <p>First, the cmakelib with required components must be added. Then the Packages must be defined with <code>BA_PACKAGE_LIBRARY</code> macro. Finally the Package can be included with <code>FIND_PACKAGE</code>.</p> <pre><code># Add cmakelib with components\nFIND_PACKAGE(CMLIB COMPONENTS CMDEF CMUTIL STORAGE REQUIRED)\n\n# Define curl and zlib Packages\nBA_PACKAGE_LIBRARY(curl v7.79.1)\nBA_PACKAGE_LIBRARY(zlib v1.2.11 OUTPUT_PATH_VAR ZLIB_ROOT)\n\n# Find zlib and curl Package\nFIND_PACKAGE(ZLIB REQUIRED)\nFIND_PACKAGE(CURL REQUIRED)\n</code></pre> <p>Note</p> <p>The <code>ZLIB_ROOT</code> is a helper variables for <code>zlib</code> Package, because <code>zlib</code> does not provide a CMake config file.</p> <p>Note</p> <p>Each of the cmakelib components has its own git repository and adds specific functionality. Any or none of the following components can be used:</p> <ul> <li>CMDEF - adds wrappers for basic CMake features</li> <li>CMUTIL - Provides functionality for other cmakelib components</li> <li>STORAGE - mechanism for storing and retrieving build dependencies</li> </ul>"},{"location":"example_usage/#build-a-project","title":"Build a Project","text":"<p>At this point, the Project can be built with <code>cmake</code> in the usual way:</p> <pre><code>mkdir -p _build &amp;&amp; cd _build\ncmake ..\nmake -j 8\n</code></pre>"},{"location":"example_usage/#create-an-app-from-project","title":"Create an App from Project","text":"<p>The example Project with dependencies was built in previous step. Now the built Project may be added to a Package Context as an App, which can then be built and distributed in the same way as Packages.</p>"},{"location":"example_usage/#modify-cmakelists","title":"Modify CMakeLists","text":"<p>As previously mentioned, the Apps can't have any dependencies. So the example Project must be built in a way that it has all its dependencies packaged with it. To achieve this, the <code>CMakeLists.txt</code> of the Project must be modified to use macros for installing like this:</p> <pre><code># Install created target\nCMDEF_INSTALL(TARGET example-project)\n\n# Install all shared library dependencies needed for json_target\n# and update RUNPATH.\nBA_PACKAGE_DEPS_IMPORTED(example-project)\n</code></pre> <p>With this code, the <code>example-project</code> target and its dependencies are installed and the RUNPATH is updated. When building with Packager, the files will be installed inside a Docker container and then they will be extracted and packaged into an App archive.  </p>"},{"location":"example_usage/#add-app-config-to-package-context","title":"Add App Config to Package Context","text":"<p>Now the App can be added to a Package Context.</p> example App Config <p>Following JSON is the Release variation App Config for the example Project. The Config is very similar to previously defined Package Configs in this example. The only important changes are to Git URI and Package name to reflect this example Project.</p> <pre><code>{\n  \"Env\": {},\n  \"Git\": {\n    \"URI\": \"https://github.com/bacpack-system/example-project.git\",\n    \"Revision\": \"v1.0.0\"\n  },\n  \"Build\": {\n    \"CMake\": {\n      \"Defines\": {\n        \"CMAKE_BUILD_TYPE\": \"Release\"\n      }\n    }\n  },\n  \"Package\": {\n    \"Name\": \"example-project\",\n    \"VersionTag\": \"v1.0.0\",\n    \"PlatformString\": {\n      \"Mode\": \"auto\"\n    },\n    \"IsLibrary\": false,\n    \"IsDevLib\": false,\n    \"IsDebug\": false\n  },\n  \"DockerMatrix\": {\n    \"ImageNames\": [\n      \"fedora41\"\n    ]\n  }\n}\n</code></pre>"},{"location":"example_usage/#build-the-app","title":"Build the App","text":"<p>This App can be built using Packager with following command:</p> <pre><code>bap-builder build-app \\\n            --context context \\\n            --image-name fedora41 \\\n            --output-dir package_repo \\\n            --name example-project\n</code></pre> <p>After this command, the Packager creates a zip archive of the App. If it is extracted, the directory structure looks like this:</p> <pre><code>example-project_v1.0.0_x86-64-fedora-41\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 example-project\n\u2514\u2500\u2500 lib\n    \u251c\u2500\u2500 cmake\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 example-project.cmake\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 example-project-release.cmake\n    \u251c\u2500\u2500 libcrypto.so -&gt; libcrypto.so.3.2.4\n    \u251c\u2500\u2500 libcrypto.so.3 -&gt; libcrypto.so.3.2.4\n    \u251c\u2500\u2500 libcrypto.so.3.2.4\n    \u251c\u2500\u2500 libcurl.so\n    \u251c\u2500\u2500 libssl.so -&gt; libssl.so.3.2.4\n    \u251c\u2500\u2500 libssl.so.3 -&gt; libssl.so.3.2.4\n    \u251c\u2500\u2500 libssl.so.3.2.4\n    \u251c\u2500\u2500 libz.so\n    \u251c\u2500\u2500 libz.so.1\n    \u2514\u2500\u2500 libz.so.1.2.11\n</code></pre> <p>As can be seen, the extracted structure contains the <code>example-project</code> binary in <code>bin</code> directory and all its dependencies in <code>lib</code> directory. Now the App can be easily extracted to a system based on fedora41 image.</p>"},{"location":"term_definition/","title":"Term definition","text":"<p>This document defines the terms used in this documentation.</p> <ul> <li>Component - BacPack system component</li> <li>Project - CMake based project</li> <li>Package - a set of files which is an output of CMake build; the definition of Package can  have any number of dependencies</li> <li>App - same as Package, except it cannot have any dependencies in its definition</li> <li>Config - Package definition as a JSON file</li> </ul>"},{"location":"use_cases/","title":"Use cases","text":"<p>This document describes several use cases for the BacPack System. Some of these use cases are described further in Usage.</p>"},{"location":"use_cases/#package-context-management","title":"Package Context Management","text":"<p>This section describes use cases related to managing a Package Context. After adding and updating a Package, the Package should be built, which is described in Build a Package from Package Context use case.</p>"},{"location":"use_cases/#add-package","title":"Add Package","text":"<p>After adding a Package Config to Package Context, the Package can be built by Packager and hosted in a Package Repository. The Package can then be easily added to Projects by including it in CMakeLists.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Packager\n  participant Package Repository\n  participant Package Context\n  participant Package Tracker\n  participant Project\n\n  User-&gt;&gt;Package Context: Adds Package definition\n  User-&gt;&gt;Packager: Build Package</code></pre>"},{"location":"use_cases/#update-package","title":"Update Package","text":"<p>Updating a Package means changing the Package Config in Package Context and then rebuilding the Package. Changing the version tag also requires removing the old version Package from the Package Repository before building the new version.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Packager\n  participant Package Repository\n  participant Package Context\n  participant Package Tracker\n  participant Project\n\n  User-&gt;&gt;Package Context: Updates Package definition\n  opt if version tag changed\n    User-&gt;&gt;Package Repository: Remove old Package\n  end\n  User-&gt;&gt;Packager: Build Package</code></pre>"},{"location":"use_cases/#remove-package","title":"Remove Package","text":"<p>Removing a Package from Package Context means removing the Package Config from Package Context and then removing the Package from the Package Repository.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Packager\n  participant Package Repository\n  participant Package Context\n  participant Package Tracker\n  participant Project\n\n  User-&gt;&gt;Package Context: Remove Package definition\n  User-&gt;&gt;Package Repository: Remove Package</code></pre>"},{"location":"use_cases/#build-a-package-from-package-context","title":"Build a Package from Package Context","text":"<p>The Packager is used to build Packages/Apps from Package Context. The built Packages are then uploaded to a Package Repository. The Packages in Package Context form dependency trees, therefore Packager supports several ways how to build the Packages:  - build single Package  - build single Package with its dependencies  - build all Packages which depends on a Package  - build all Packages in Package Context</p> <p>These use cases are described in detail in Packager documentation.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Packager\n  participant Package Repository\n  participant Package Context\n  participant Package Tracker\n  participant Project\n\n  User-&gt;&gt;Packager: Initiates Package build\n  Package Context-&gt;&gt;Packager: Retrieves Package definitions\n  Packager-&gt;&gt;Packager: Package build\n  Packager-&gt;&gt;Package Repository: Uploads built Packages</code></pre>"},{"location":"use_cases/#use-already-built-packages-in-project","title":"Use already built Packages in Project","text":"<p>To use a Package that was built with Packager and uploaded to a Package Repository, use Package Tracker macros to add this Package to the application. The Package Tracker repository URL must also be set in <code>CMLibStorage.cmake</code> in the root directory of the application.</p> <pre><code>sequenceDiagram\n  actor User\n  participant Packager\n  participant Package Repository\n  participant Package Context\n  participant Package Tracker\n  participant Project\n\n  User-&gt;&gt;Project: Puts link of Package Tracker\n  User-&gt;&gt;Project: Adds desired Package to CMakeLists\n  User-&gt;&gt;Project: Initiates Project build\n  rect\n    Note right of Package Repository: Project build\n    Project-&gt;&gt;Package Tracker: Asks for Packages\n    Package Repository-&gt;&gt;Package Tracker: Retrieves Packages\n    Package Tracker-&gt;&gt;Project: Adds Packages to build\n    Project-&gt;&gt;Project: FIND_PACKAGE&lt;br&gt;for each Package\n    Project-&gt;&gt;Project: Project build\n  end</code></pre>"}]}